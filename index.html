
<html>
    <head>
        <link rel="stylesheet" type="text/css" href="style.css">
        <title> WebGL on a 90's page </title>
    </head>
    <body>
    <div id = "wrapper" class="noselect">
        <div id="header">
            
            <div id="icon">
			<!-- ICON JS GEN-->
			</div>
            <div id="title">
				<h2 class="rainbow"> A webpage lost in time</h2>
			    <div id="content">
				    <p class="rainbow"> My sense of design is mine, therefore its good.  </p>
			    </div>
			</div>
        </div>

		<div id="data">
            <div id="side">
		        <div id="ratepicker"  unselectable='on' onselectstart='return false;'>
			        <div id="larrow" onclick="boostRate(-1);"> &laquo </div>
			        <div id="rarrow" onclick="boostRate(1);"> &raquo </div>
			        <div id = "currate"></div>
			    </div>

			    <div id="leftbar">
			    	<p id = "blurb"> 
                        Hi. Name's Abdi Dahir and this is a place for me to mark
                        the web in w/e strange way I feel.
                    </p>
			    	<p id = "blurb"> 
                        I have a ton of interests and maybe not enough focus. I 
                        will have a little more to show for myself then a fractal 
                        patterned orb soon.
                    </p>
			    	<p id = "blurb-small"> 
                        1K3tSx6hgz13Vx4A8Rt6pKZWNnBSFLEu3f 
			    	</p>
			    	<div id="section80">
			    		<h4 id="section" class="rainbow"> links </h4>
			    		<ul>
			    			<li>
                                <a href="index.html"> blog </a>
			    			</li>
			    			<li>
                                <a href="start.html"> start </a>
			    			</li>
			    			<li>
                                <a href="fall2014.html"> fall 2014 </a>
			    			</li>
                            <li>
                                <a href="winter2014.html"> winter 2014 </a>
			    			</li>
                            <li>
                                <a href="spring2015.html"> spring 2015 </a>
			    			</li>
                            <li>
                                <a href="summer2015.html"> summer 2015 </a>
			    			</li>
                            <li>
                                <a href="fall2015.html"> fall 2015 </a>
			    			</li>
                            <li>
                                <a href="winter2015.html"> winter 2015 </a>
			    			</li>
                            <li>
                                <a href="summer2021.html"> summer 2021 </a>
			    			</li>
			    		</ul>
			    	</div>

			    	<div id="section80">
			    		<h4 id="section" class="rainbow"> on the ground </h4>
			    		<ul>
			    			<li>
                            <del><p id= "location"> tdot: bahen center </p></del>
			    			</li>
			    			<li>
			    			<del><p id="location"> brooklyn: outpost </p></del>
			    			</li>
			    			<li>
			    			<del><p id="location"> sf: another cafe</p></del>
			    			</li>
			    			<li>
			    			<del><p id="location"> sf: social study</p></del>
			    			</li>
			    			<li>
			    			    <p id="location"> vancouver: covid</p>
			    			</li>
			    			<li>
			    				<p id="location"> work: relic</p>
			    			</li>
			    		</ul>
			    	</div>

			    	<div id="section80">
			    		<h4 id="section" class="rainbow"> on the web </h4>
			    		<ul>
			    			<li>
			    				<a href = "https://github.com/snkz"> github.com/snkz </a>
			    			</li>
			    			<li>
			    				<a href = "https://twitter.com/snkz"> twitter.com/snkz </a>
			    			</li>
			    			<li>
			    				<a href="mailto:abdi.dahir@outlook"> abdi.dahir@outlook.com </a>
			    			</li>
			    		</ul>
			    	</div>

			    </div>
            </div>
            <div id="block-blog">
                <div id="block-text" class="reselect">
                  <p id="engine"> Jan 8 2022: </p>
                  <h4> Learning to polish</h4>

                  <p>
                  I'm not apologizing, I'll just try to do better then yesterday with how often I write.
                  </p>

                  <p>
                  Covid is running on year 3 now and its not been the best for my work ethic. However I'm incredibly happy with how my art has improved over the last year.
                  The main thing is detailing, leaving blank walls, floors, solid colours etc I thought looked fine; gave it a toy box/doll house feel I thought. Now though I feel more then anything it just comes off as unfinished. If I were generating content programmatically I think I could get away with this but I am not. Hell if the game wasnt based on an IP I think I could of gotten away with it.
                  </p>

                  <p>
                  The detailing I will try to focus on for any new scenes and characters I make are:
                  <br />
                      1. No solid colours. Break it up with blotches of slightly saturated version of w/e colour.
                  <br />
                      2. Avoid large flat areas, delete a voxel or two, add more objects.
                  <br />
                      3. Walls and floors must have a pattern, but that pattern cannot take up the whole area. Solid is fine to accent.
                  <br />
                  <br />

                  My latest posts on twitter I think show the imporvement. Because of this too i'm more confident about rendering at higher resolutions instead of going for the 480x320 pixelated look. I think its better for it overall.
                  </p>

                  <p>
                  I'm more deadset on making a medabots game now too, even without the license I'm at the point where I'm willing to get this game out as free downloaded if needed. Maybe open up a patreon to earn something off it. I want to finish this, at any cost!
                  </p>

                  <strong> Until my next post, see you here or on Guilty Gear Stive's tower! </strong>

                </div>
                <div id="seperator"></div>
                <div id="block-text" class="reselect">
                  <p id="engine"> June 9 2021: </p>
                  <h4> Getting back to blogging</h4>

                  <p>
                  Hello yes this site is still active ...
                  </p>

                  <p>
                  I haven't made time to update this site in a long time but I still really love it. Having a record of thoughts from now 7 years ago is so inspiring and sometimes pretty cringey... feels good to share it either way. Still love the aesthetic though and of course am still actively developing the game engine. However I mostly update that on twitter now. Please check out images and gifs there.
                  </p>

                  <p>
                  Since the last blog update, I've switched jobs once more and managed to get a sick work schedule a year in. This gave me so much time to really build out the game. Its honestly come along way from its humble roots as a <a class="inlinea" href="http://abdi.dahir.ca/breakblox.html">voxel render</a>. I think i'm a bit addicted to world building/story telling though so I'm hoping to make it a decently long (10hrs?) rpg in the medabots universe. I love the characters and maybe I can get the license, if not, generic mini-robot-battler go! I'm still designing as I make tech so nothing is really set in stone but I'm alot more structured about it all now though and the number of things the game can be gets smaller and smaller each day which is a great sign if I ever want to finish haha.
                  </p>

                  <p>
                  I'm on and off with how heads down I am with working on this normally, but covid this year has made it a bit rocky. Something about staying in to do work when I just spent all day working from home on my official job isnt really too enticing ...
                  </p>

                  <strong> You will hear from me again ... soon ... probably! </strong>

                </div>
                <div id="seperator"></div>
                <div id="block-text" class="reselect">
                  <p id="engine"> Dec 17 2017: </p>
                  <h4> Improved engine and new flames</h4>

                  <p>
                  It's been a crazy year, I've moved to Vancouver, jumped jobs twice and am more deadset then ever on building this thing out
                  </p>

                  <p>
                  I've learned alot at artillery and maxis, mostly about engine design and entity component systems. I've trashed most of my old code and rebuilt 
                  the voxel engine as a proper game engine. I've put in alot of work on the lua bindings and now have a clean interface between lua code and c++ code
                  that's all handled behind the scenes my the engine. All C++ components and events can be have lua code bound to them by simply adding handlers such as OnEventName(arg1, ... argN) with no fancy bridge code other then a single macro, DEFINE_EVENT(onEventName, argType1 ... argTypeN). Theres also macros for exposing any memeber variable of a class to lua allowing for the lua file to both read and set the value. Its cool. I'll show it off here at somepoint.
                  </p>

                  <p>
                  Thats all nice and everything but I still haven't built a new game since 2014 and I want that to change this coming year. I'm working fast towards a prototype trying to minimize distractions (Its so hard to not work on fun rendering stuff). My current fulltime job has great work life balance so things are looking up.
                  </p>

                  <strong> You will hear from me again soon! </strong>

                </div>
                <div id="seperator"></div>

                <div id="block-text" class="reselect">
                  <p id="ui"> April 30 2016: </p>
                  <h4> UI and text rendering woes</h4>

                  <p>
                  <strong>Work work work,</strong>  but I've made some time to look at the engine a bit more.
                  </p>

                  <p>
                  So I've been looking at performance and started measuring specific parts of the rendering pipeline. I haven't been getting good FPS
                  lately and I mostly assumed it was due to the voxel code, hence all the threading work. What I forgot to pay attention to was the 
                  text rendering code I slapped in! It alone took up two thirds of my rendering time! It obviously needed to go!
                  </p>

                  <p>
                  I've been using FreeType <a class="inlinea" href="https://en.wikibooks.org/wiki/OpenGL_Programming/Modern_OpenGL_Tutorial_Text_Rendering_01"/>
                  following this very helpful guide</a> which got me to a point where I could simply write text to the screen. However due to the lack of caching
                  and constant texture generation, my FPS took a serious hit. At the time, I was still at 60FPS (I normally have vsync on blah) so it went unnoticed
                  and performance was not my first priority.
                  </p>

                  <p>
                  I had the option of figuring out how to improve on this or move away from it entirely and finally start looking at some UI libs.
                  I decided to go with the latter and have started using <a class="inlinea" href="https://github.com/ocornut/imgui">ImGui</a> a 
                  very self contained library that does basically everything  I need currently. My FPS on my windows machine is now at something ridiculous like 1200FPS in top down view and around 500FPS in free cam.
                  </p>

                  <br/>
                  <a href="https://www.youtube.com/watch?v=VKBHxDioHi0">You can view the UI Demo here.</a>
                  <br/>

                  <p>
                  Obviously I'm pretty happy with the switch, I'm not too sure how practical this lib will be in the long run but I'm tempted to find out :p
                  </p>
                </div>
                <div id="seperator"></div>
                <div id="block-text" class="reselect">
                  <p id="persistent"> January 3 2016: </p>
                  <h4> Persistent Data && Threading Opts</h4>

                  <p>
                  So as you may of noticed, I took a bit of a break due to the new job. Work is exciting and consuming 110% of my time but since I've been on
                  break, I obviously took the time to tackle more of the game.
                  </p>

                  <p>
                  So although I did do most of the multithreading work in July, I did not take the time to debug it thourghly or truly break down all work to be
                  exclusively local to chunks. i.e lighting was not threaded. More importantly, rendering required all threads to stop before I could
                  render out a chunk. I ran the risk of corrupting data being bound to the gpu. Fortunately I banged my head against my keyboard to sort that
                  out using the minimal amount of blocking code. Threads no longer need to be barrier synchornized while I write to GPU memory.
                  </p>

                  <p>
                  The solution mostly boiled to keeping two states, the currently bound state of the chunk, and the current active state of the chunk. 
                  I maintained seperate values for things such as block count, x,y,z regions start and length in the buffer etc. One for the version that is 
                  currently bound to gpu memory and one for the version that is not. This does not mean chunk data was duplicated 100% of the time, it just means 
                  the vertex data thats normally just on the gpu and sometimes on the stack was kept around longer then before and was only cleared at the time 
                  of the next glBindBuffer call. When that call is made I copy the current state synchronisly (just few integers needed) and release locks allowing 
                  any thread to attempt to reupdate the vertex data if need be. This allows me to render and recreate meshes at the same time. 
                  </p>

                  <p>
                  Lighting basically required a rewrite of the floodfill algorithm which I originally got from <a class="inlinea" href="https://www.seedofandromeda.com/blogs/29-fast-flood-fill-lighting-in-a-blocky-voxel-game-pt-1">the guys making Seed of Andromeda</a>. The change mostly revolved around the addition of a lock and local queues.
                  </p>

                  <br/>
                  <a href="https://www.youtube.com/watch?v=Lh4m8PMbS7E">I made a quick demo earlier to demonstrate that portion of the update.</a>
                  <br/>

                  <p>
                  After feeling pretty confident about my threading skills I decided to crush that confidence by attempting to thread reading/writing chunks.
                  I did manage to get this all working but my self-esteem did not hold out unfortunately. Currently I am writing out each chunk to its own file
                  based on it's position. Since I reuse chunks as I move around the world, assigning a chunk an id and using that as the file name is not helpful.
                  Position's worked fine as long as I made sure to synchronize read and writes to a chunk file. Otherwise I run the risk of overwriting file with
                  chunk data of chunk that was recently reassigned the conflict creating position.
                  </p>

                  <p>
                  The synchronization between the update calls and the read/write calls was mostly a freebie due to how I organized chunks that required unloading.
                  If a chunk is in the unloading queue, it cannot be repositioned or put into the update queue. Only chunks stored in a free queue can be reinited.
                  </p>

                  <p>
                  Thanks to SDL's <span class="code inlinea">SDL_GetPrefPath(orgname, dirname)</span> function, there was very little os specific code necessary.
                  That call provided the correct directory to write to, the only extra work was making a safe mkdir call which I did like so.
                  </p>

                  <br/>
                  <p class="code">
                    int mkdir_safe(const char* path) {
                    <br/>
                    #ifdef __linux__
                    <br/>
                        &nbsp;&nbsp;return mkdir(path, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
                    <br/>
                    #else
                    <br/>
                        &nbsp;&nbsp;return mkdir(path);
                    <br/>
                    #endif
                    <br/>
                    }
                  </p>
                  <br/>

                  <p>
                  Please excuse the laziness, ideally the #ifdef would be defined for windows and default to the posix mkdir call, however I did not
                  want to enumerate the possible windows/windows compiler flags
                  </p>

                  <p> 
                  Finally a point on the format, currently i'm writing out the chunk byte for byte, so each chunk file is always 32KB. I intend to run encode the files
                  shortly. The next step will be to organize multiple chunks into a single file, ala minecrafts region files. I do not envision that being too complicated
                  given the right amount of synchronization.
                  </p>

                  <strong> BUT OMG IT WORKS!!! </strong>
                  <p>
                  Yea persistence, woo! The next thing I'd like to tackle is building out an entity/component system. Work has inspired me to build out a proper
                  game engine. Having a clear separation between engine and game code at work allows everyone to make a tremendous amount of change on the fly. I really
                  want that. I will have it!
                  </p>
                </div>
                <div id="seperator"></div>
                <div id="block-text" class="reselect">
                  <p id="mingw"> July 29 2015: </p>
                  <h4> Cross compilation with mingw </h4>

                  <p>
                  So first, I'd like start out by thanking all the compiler people out there. Honestly, you don't get enough love. You're all the best.
                  </p>

                  <p>
                  My experience with emscripten has been mostly great, ignoring the SDL2 hiccups I ran into, porting to the web was surprisingly easy.
                  I feared the worst for mingw though, so I originally attempted to port the code over to Visual Studio. ... which was incredibly painful.
                  </p>

                  <p>
                  Turns out mingw is not so bad, as long as you are on Arch Linux! Every library that you would like cross compiled has been packaged up
                  nicely for you in the AUR. The only thing you need to do is include them. I did this and boom my code ran on ...
                  </p>

                  <br/>
                  <a href="https://www.youtube.com/watch?v=F2ynNBoVlbc">Winnnnddoowwws.</a>
                  <br/>

                  <p>
                  The only tricky bit is sorting out the Makefile required. I've attached the one I used which will hook up your SDL2, GLEW, freetype 
                  GLM and lua dependancies. I installed each one of this packages again using the AUR mingw-w64-* version. I believe 64 bit is required to 
                  get C++ threading to work out of the box. Either way, you can pick to build a 32 bit version simply by changing the architecture in the Makefile
                  from x86_64 to say i686.
                  </p>

                  <p class="code">
                        <br/>
                        # Build tool
                        <br/>
                        CC = /usr/bin/x86_64-w64-mingw32-gcc
                        <br/>
                        CXX = /usr/bin/x86_64-w64-mingw32-g++
                        <br/>

                        # Build flags
                        <br/>
                        CPPFLAGS = -O3 -std=c++11 -Wall -pthread -DGLEW_STATIC 

                        <br/>
                        # Includes
                        <br/>
                        CPPFLAGS +=  -I/usr/x86_64-w64-mingw32/include/  -I/usr/x86_64-w64-mingw32/include/freetype2/
                        <br/>

                        # LD Flags
                        <br/>
                        LDFLAGS = -L/usr/x86_64-w64-mingw32/lib
                        <br/>

                        # LD Libs
                        <br/>
                        LDLIBS = -static `/usr/bin/x86_64-w64-mingw32-sdl2-config  --libs` -ldinput8 -ldxguid -ldxerr8 -luser32 -lgdi32 -lwinmm -limm32 -lole32 -loleaut32 -lshell32 -lversion -luuid -lglew32 -lopengl32 -lm -llua -lfreetype 
                        <br/>

                        # Source
                        <br/>
                        main: yourcode.o
                        <br/>

                        # Build Souurce
                        <br/>
                        all: main
                  </p>

                  <br/>
                  <p>
                  I'm a bit of a Makefile noob, so please excuse any strangeness. (Like how i'm creating a 'exe' main without the proper extension
                  <br/>
                  <br/>
                  A few interesting things about this Makefile. 
                  <br/>
                  1. The mingw32/include/ section deals with GLM and Lua automatically as I installed both of them via AUR so they were added into the folder correctly. Even though GLM doesn't need to compiled, Its more convient to just have it included the same way the other libs are
                  <br/>
                  2. -DGLEW_STATIC and -static flag are REQUIRED, mingw is more then happy to dynamically link to libraries, this forces SDL2 and GLEW to compile statically
                  <br/>
                  3. I have no idea what the libs after the sdl config to -lglew32 are, but I do know that SDL2 will not link without them. They seem to have something to 
                  do with window's keyboard handling? 
                  </p>

                  <p> 
                  I also put in a TOOOON of working making the terrain infinite. I would love to dedicate a blog post to it but I don't think I'm done with it just yet.
                  I would love for it to be faster, but hey ... looks pretty no?
                  </p>

                  <p>
                  Really though, I intend to make the game ... soon. Next post HAS to be update game content. 
                  </p>
                </div>
                <div id="seperator"></div>
                <div id="block-text" class="reselect">
                  <p id="threading"> July 16 2015: </p>
                  <h4> Multithreading in OpenGL </h4>
                  <p>
                  So whenever I read posts by voxel engine writters that list features they've implemented, 
                  Multithreading is almost always listed as a simple bullet point. They then go on to talk about
                  meshing problems, LOD etc. There's very little discussion on how they implented it. I'm gonna try to change that
                  cause damn does it ever suck to multithread code with OpenGL being single thread only. 
                  </p>

                  <p>
                  So I lied a bit, OpenGL does support multithreading with shared contexts but as far as I can tell, the API to do it
                 is windowing system specific, i.e OS specific. This wasn't really a path I wanted to go down. Thankfully, its not that big of
                 deal, it just lead to a very important condition that I needed to mantain.
                  </p>

                  <strong> ALL glXXXXX Methods must happen on thread that inited the context!</strong>

                  <p>

                  This was a bit unfortunate, I was originally planning on threading my mesh generation code directly, i,e no changes to its implementation.
                  It originally created a fixed size buffer on the stack and stored all the mesh vertecies. This was then immediately bound to a chunks VBO
                  and discarded when the function returned. The last step, binding to the VBO would not be possible anymore if this were running in a seperate
                  thread. This ment that the mesh could not be stored on the stack, which then lead to the abstraction of the mesh and heap allocation for its 
                  storage. The code was updated so that the chunk had a reference to a mesh object, it would write to it when the mesh generation function was
                  called and cleared after the main thread bound its data to a VBO.
                  </p>

                  <p>
                  Now in order to define what work a thread would do and what the thread would do after its completion. I created a threadPool class with two queues.
                  A workQueue and a responseQueue. The workQueue would take a task structure which contained data to be worked on and a C++ lambda function (yea! lambdas!)
                  to execute on this data. The responseQueue would take the result of the lambda function. The two queues would be synchronized with their own mutex and 
                   wait channel. I'm actually very proud of this threadPool class, I'll be posting it on github soon, its just a header and it provides basically
                 everything I need for controlling the threadPools work flow, pausing work, adding work etc.

                  <br />
                  <br />
                  So when it comes time to render the scene, I pause all active threads and I drain the responseQueue of its completed meshes, binding them all.
                  I compute visible chunks and for any chunks that need updating, I push it on to the queue with a lambda function executing its mesh generation method.
                  After the scene is rendered I resume all threads! Boom multithreading!

                  <br/>
                  <br/>

                  ... Except for the work order. So if you were to just keep pushing chunks that needed updating onto the queue, your worker threads would not be 
                  able to keep up, causing them to continue to work on chunks that arent visible to the player anymore. You could use a stack instead of a 
                  queue to deal with this issue. On top of work order, at least for me, I had issues where the same chunk was on the workQueue multiple times. I do not
                 do any checking to see if the chunk exists in the queue or if it still needs updating. I prefered to just wipe the workQueue during the pause and drain 
                 response phase and mantain the queues FIFO ordering instead.
                  </p>

                  <p>
                  After getting all that sorted out, I gained level of detail for free. I can set the 'sample' rate in my mesh generator (It just sets the increment step
                 in the various for loops) based on distance away from the player and push the chunk on to the workQueue if the sample rate changed. 
                  <br/>
                  <br/>

                  Of course, this leads to issues in areas where chunks at different LOD meet. I got around this by extending each chunks mesh by one sample step. It works
                  pretty well, there's still times where holes are visible but I enjoy the effect enough to not care.
                  </p>

                  <br/>
                  <a href="https://youtu.be/XT_NXsXkkMI">Here's a vid of it.</a>
                  <br/>

                  <p>
                  I swear I'll get back to the game part of this reaaalll soon.
                  </p>
                </div>
                <div id="seperator"></div>
                <div id="block-text" class="reselect">
                  <p id="segments"> July 10 2015: </p>
                  <h4> Voxel Segmentation </h4>
                  <p>
                  I've been working on how enemies should be fought in my game 
                  and I've decided that in order to best take advantage of the 
                  engine, enemies should die by being broken apart. i.e whenever
                  an enemies body becomes disjoint, all or one disjoint set of 
                  their body should be destroyed. Sounds fun buuuut its been a 
                  pain getting in order. This post will discuss what I've 
                  learned about set segmentation for voxel data.
                  </p>

                  
                  <p>
                  First my assumptions:
                  <br />
                      1. Enemy starts off completely connected
                  <br />
                      2. Enemy loses at most one voxel at a time
                  <br />
                      3. Diagonal voxels are not considered connected
                  <br />
                  <br />
                  Nothing crazy but should be stated. With this I began building
                  out a soloution. I initially came to the conclusion that the 
                  only way a set could ever become disjoint is if the voxel 
                  currently being removed was one of only three voxels in a 
                  neighbourhood around the voxel. The idea was, if we assume up 
                  untill this point that the enemy was fully connected (i.e 
                  there exists a curve in between any two points on the enemy such
                  that every point on this curve is contained in a voxel of the enemy)
                  then removing a single voxel is only destructive if it was the only point between
                  it and its two neighbours!
                  <br />
                  <br />

                  So now the problem became this: If a voxel that just got removed fit the above description, 
                  it being one of three voxels in a neighbourhood. How do I know if it created a disjoint set?
                  How do I know that there doesn't exist another path between the two voxels neighbouring this guy
                  that I just orphaned?
                  </p>

                  <strong> Does there exist another path between these two voxels? </strong>

                  <p>
                  Sounds like a path finding problem, sounds like I'm writing A*. 
                  <br/>

                  <br/>

                  <a href="https://www.youtube.com/watch?v=OZTb1lvjVAM&feature=youtu.be">So I did this.</a>
                  <br/>
                  Attached is a video of it in action. After determining if removing a voxel creates
                  two disjoints sets. I flood fill the two sets using the orphaned points as seeds and paint them red or blue.
                  Since my player character deletes multiple voxels at a time, when a disjoint set happens to be small, it may be 
                  deleted immediately by the characters missile. Hence the case where the enemy is painted fully blue or red.
                  <br/>
                  <br />

                  Seems to work right? WRONG!
                  </p>

                  <p>
                  You may of guessed this but the assumption of there being only two orphaned neighbours possible is based
                  on the assumption that removing a voxel can create at most two disjoint sets. This is incorrect. At most
                  6 orphaned neighbours are possible creating 6 disjoint sets IF the removed voxel was say the center of 
                  some star like enemy. Imagine 1x1 path shooting out of every face of this to-be-removed voxel. The set was originally
                  connected, however this one little piece was holding it all together. A* on just two voxels is not enough ... 
                  </p>

                  <p>
                  I'll post an update when I sort this out. 
                  <br/>
                  In other news I have lua bindings now wooot :p, ill do an update on that too!
                  </p>
                </div>
                <div id="seperator"></div>
                <div id="block-text" class="reselect">
                  <p id="begins"> June 28 2015: </p>
                  <h4> It begins...</h4>
                  <p>
                  So I've started working on my third attempt to make a game out
                  of my voxel engine. I believe in this one alot so I'm going to
                  start documenting some of its developement.
                  <br />
                  I'm making a voxel space shooter crossed with megaman. Think 
                  megaman bosses but in space and with destructiable bodies. 
                  </p>

                  
                  <p>
                  Destructiable enviornments are pretty straightforward in a 
                  voxel engine, the volume data for an enviornment is static so 
                  intersections are pretty trivial. Chunks are generally axis 
                  alligned too, meaning no funky transformations are needed to 
                  check point collisions. My engine currently organizes fixed 
                  sized chunks in a octree, so when I want to shoot one of my 
                  asteriods I query the octree picking up chunks along the ray 
                  as I pass em and tracing through them to look for collisions. 
                  </p>

                  <p>
                  But what happens when these chunks are rotating around and 
                  moving? For my voxelized enemies this will be pretty common so 
                  my first task was to sort out intersections with arbitrary 
                  positioned/alligned chunks. My current soloution, like most raytracing 
                  renders (mine is not fyi) is to transform any ray into the 
                  chunks object space. This can be done my multiplying the 
                  incoming ray by the inverse of that chunks model matrix (its 
                  translations, rotations etc.) and checking to see if the ray 
                  crosses then. Its a simple trick and solves my problem.
                  </p>
                  

                  <p>
                  I use this trick as well to determine which faces of the enemy to 
                  render. I transform the cameras position into the enemy chunks 
                  object space which allows me to simply check to see if the 
                  camera is infront of or behind a voxel face using the extents 
                  of the chunk. This would not of been possible in world space 
                  where a face could of been unalligned with the axes.
                  </p>
                  

                  <br/>
                  <a href="https://www.youtube.com/watch?v=iXLHjo1UnwM">I've uploaded a demo video to show how it works.</a>
                  <br/>

                  <p>
                  Hopefully I'll have more to show you in the future. 
                  </p>

                </div>
            <div id="seperator"></div>
            </div>
		</div>
		
	<!-- shadaah -->
    <script id="vertexShader" type="x-shader/x-vertex">
        precision highp float;

        varying vec2 vUv;
        attribute float displacement;
        varying vec3 vNormal;
        uniform float amp;

        void main() {
            vNormal = normal;
            vUv = uv;
            vec3 newPos = position; // + normal * vec3(displacement * amp);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0 );
        }

    </script>
	<script id="juliaSINE-fs" type="x-shader/x-fragment">
	precision highp float;

	uniform float time;
	uniform vec2 resolution;
	varying vec2 vUv;
	varying vec3 vNormal;
	uniform float amp;
    uniform float mousex;
    uniform float mousey;

	float cosh(float val)
	{
		float tmp = exp(val);
		float cosH = (tmp + 1.0 / tmp) / 2.0;
		return cosH;
	}
	
	float sinh(float val)
	{
		float tmp = exp(val);
		float sinH = (tmp - 1.0 / tmp) / 2.0;
		return sinH;
	}
	void main(void) {
		vec2 position = vUv;
		float x = (position.x - 0.5) * 9.42;
		float y = (position.y - 0.5) * 9.42;
	
		float hue;
		float saturation;
		float value;
		float hueRound;
		int hueIndex;
		float f;
		float p;
		float q;
		float t;
	
		int itter = 256;
		//float cx = 1.0;
		//float cy =  1.9;
		//float cx = 1.2;
		//float cy =  0.5;
		float cx = mousex;
		float cy =  mousey;
	
	
		float tempX = 0.0;
		float ctempX = 0.0;
		int i = 0;
		int runaway = 0;
		float z = 0.0;
		float zf = 0.0;
	
	
		for (int i=0; i < 256; i++) {
	
			tempX = sin(x) * cosh(y);
			y = cos(x) * sinh(y);
			x = tempX;
	
			ctempX = x * float(cx) - y * float(cy);
			y = x * float(cy) + y * float(cx);
			x = ctempX;
			z = x*x + y*y;
			if (runaway == 0 && z > 2500.0) {
				runaway = i;
				zf = sqrt(z);
				//break;
			}
		}
		float br = 0.0;
		if (runaway != 0) {
			//NIC COLOURING
			//float z = sqrt(xf*xf + yf*yf);
			br = log2(1.75 + float(runaway) - log2(log2(zf))) / log2(float(itter));
	
		} else {
			//gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
			br = log2(1.75 + float(itter) - log2(log2(z))) / log2(float(itter));
			br = 1.0;
	
		}
		gl_FragColor = vec4(abs(br - amp), abs(amp*amp - br*0.75), amp*amp, 1.0);
	}

	</script>

	<!-- j whattt? -->
	<script src="js/three.min.js"></script>
    <script id="main" src="js/scripts.js"></script>

    </div>
    </body>
</html>

