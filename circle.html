<html>
    <head>
        <title> Threejs bs </title>
        <style> canvas { width: 100%; height: 100% } 
                #hey { margin 0px auto; width: 100px; height: 100px; float: left; } 
                #hello { margin: 15px auto; padding-left: 10px; display: inline; float: left; } 
                #bye { padding-top: 10px; display: block; clear: left;} 
        </style>
    </head>
    <body>
        <div id="hey">
        <script src="js/three.min.js"></script>

        <script id="vertexShader" type="x-shader/x-vertex">
            varying vec2 vUv;
            attribute float displacement;
            varying vec3 vNormal;
            uniform float amp;

            void main() {
                vNormal = normal;
                vUv = uv;
                vec3 newPos = position; // + normal * vec3(displacement * amp);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0 );
            }

        </script>
        <script id="fragmentShader" type="x-shader/x-fragment">
            uniform float time;
            uniform vec2 resolution;
            varying vec2 vUv;
            varying vec3 vNormal;

            void main( void ) {

            vec2 position = vUv;
            float color = 0.0;
            color += sin( position.x * cos( time / 15.0 ) * 80.0 ) + cos( position.y * cos( time / 15.0 ) * 10.0 );
            color += sin( position.y * sin( time / 10.0 ) * 40.0 ) + cos( position.x * sin( time / 25.0 ) * 40.0 );
            color += sin( position.x * sin( time / 5.0 ) * 10.0 ) + sin( position.y * sin( time / 35.0 ) * 80.0 );
            color *= sin( time / 10.0 ) * 0.5;
            gl_FragColor = vec4( vec3( color, color * 0.5, sin( color + time / 3.0 ) * 0.75 ), 1.0 );
            //gl_FragColor = vec4( position.x, 0.0, 0.0, 1.0 );

            }
        </script>
        <script id="mandshader-fs" type="x-shader/x-fragment">
            precision mediump float;

            uniform float time;
            uniform vec2 resolution;
            varying vec2 vUv;
            varying vec3 vNormal;
            uniform float amp;


            void main(void) {
                vec2 position = vUv;
                float cx = position.x * 3.5 - 2.5;
                float cy = position.y * 2.0 - 1.0;

                //float cx = position.x;
                //float cy = position.y;

                float hue;
                float saturation;
                float value;
                float hueRound;
                int hueIndex;
                float f;
                float p;
                float q;
                float t;


                float x = 0.0;
                float y = 0.0;
                float tempX = 0.0;
                int i = 0;
                int runaway = 0;
                for (int i=0; i < 100; i++) {
                    tempX = x * x - y * y + float(cx);
                    y = 2.0 * x * y + float(cy);
                    x = tempX;
                    if (runaway == 0 && x * x + y * y > 100.0) {
                        runaway = i;
                        break;
                    }
                }

                if (runaway != 0) {
                    //NIC COLOURING
                    float z = sqrt(x*x + y*y);
                    float br = log2(1.75 + float(runaway) - log2(log2(z))) / log2(100.0);
                    //float br = float(runaway) / 100.0;
                    gl_FragColor = vec4(br - amp, amp - br, 1.0, 1.0);
                } else {
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
             }
            }
        </script>
        <script>
            var mahname = "hey";
            var div = document.getElementById(mahname); 
            // our bs goes here
            var scene = new THREE.Scene();
            var clock = new THREE.Clock();
            var targetRotationX = 0;
            var targetRotationOnMouseDownX = 0;
            var targetRotationY = 0;
            var targetRotationOnMouseDownY = 0;
            var mouseX = 0;
            var mouseX = 0;
            var mouseXOnMouseDown = 0;
            var mouseY = 0;
            var mouseYOnMouseDown = 0;


            // group
            group = new THREE.Object3D();
            group.position.x = 0.0;
            group.position.y = 0.0;
            group.position.z = 0.0

            // camera
            var camera = new THREE.PerspectiveCamera( 30, div.offsetWidth / div.offsetHeight, 1, 10000 );
            camera.position.y = 0;
            camera.position.z = 10;
            scene.add( camera );

            var light = new THREE.DirectionalLight( 0x404040 ); 
            light.position.set( 50, 200, 100 );
            light.position.multiplyScalar( 1.3 );
            light.castShadow = true;
            light.shadowMapWidth = 2048;
            light.shadowMapHeight = 2048;

            var d = 300;
            light.shadowCameraLeft = -d;
            light.shadowCameraRight = d;
            light.shadowCameraTop = d;
            light.shadowCameraBottom = -d;
            light.shadowCameraFar = 1000;
            light.shadowDarkness = 0.5;
            scene.add( light );

            light = new THREE.DirectionalLight( 0x3dff0c, 0.35 );
            light.position.set( 0, -1, 0 );
            scene.add( light );


            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(div.offsetWidth, div.offsetHeight);
            renderer.setClearColor( 0xffffff );
            div.appendChild(renderer.domElement);

            // geos
            var plane = new THREE.Mesh(
                        new THREE.PlaneGeometry(4, 4, 20, 20), 
                        new THREE.MeshBasicMaterial({ color: 0x7f7f7f, wireframe: true })
            );
            plane.rotation.x = Math.PI;

            var geometry = new THREE.SphereGeometry(2,25,25);
            //var material = new THREE.MeshBasicMaterial( {color: 0x0000ff} );

            // post proc
            var uniforms = {
                time: { type: "f", value: 1.0 },
                amp: { type: "f", value: 0.0 },
                resolution: { type: "v2", value: new THREE.Vector2() }
            };

            var attributes = {
                displacement: { type: "f", value: [] }
            };

            var material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                attributes: attributes,
                vertexShader: document.getElementById( 'vertexShader' ).textContent,
                fragmentShader: document.getElementById( 'mandshader-fs' ).textContent
            });

            var sphere = new THREE.Mesh(geometry, material);
            //var sphere = new THREE.Mesh(geometry, new THREE.MeshNormalMaterial());
            var verts = sphere.geometry.vertices;
            var values = attributes.displacement.value;

            for (var v = 0; v < verts.length; v++) {
                values.push(Math.random() * 0.50);
            }

            group.add(sphere);
            //group.add(plane);
            scene.add(group);

            function onWindowResize( event ) {
                uniforms.resolution.value.x = div.offsetWidth;
                uniforms.resolution.value.y = div.offsetHeight;
                camera.aspect = div.offsetWidth / div.offsetHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( div.offsetWidth, div.offsetHeight );
            }

            function render() {
                requestAnimationFrame(render);

                var delta = clock.getDelta();
                uniforms.time.value += delta;     
                uniforms.amp.value = Math.sin(uniforms.time.value) * 1;     

                sphere.rotation.x += 0.01;
                sphere.rotation.y += 0.02;
                sphere.rotation.z += 0.03;

                group.rotation.y += ( targetRotationX - group.rotation.y ) * 0.05;
                group.rotation.x += ( targetRotationY - group.rotation.x ) * 0.05;


                renderer.render(scene, camera);
            }


	        // click events
	        function onDocumentMouseDown( event ) {

        	    event.preventDefault();
        
        	    document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        	    document.addEventListener( 'mouseup', onDocumentMouseUp, false );
        	    document.addEventListener( 'mouseout', onDocumentMouseOut, false );
        
        	    mouseXOnMouseDown = event.clientX - div.offsetWidth/2;
	            mouseYOnMouseDown = event.clientY - div.offsetHeight/2;

        	    targetRotationOnMouseDownX = targetRotationX;
        	    targetRotationOnMouseDownY = targetRotationY;
            };

	        function onDocumentMouseMove( event ) {

	        	mouseX = event.clientX - div.offsetWidth/2;
	        	mouseY = event.clientY - div.offsetHeight/2;

	        	targetRotationX = targetRotationOnMouseDownX + ( mouseX - mouseXOnMouseDown ) * 0.20;
	        	targetRotationY = targetRotationOnMouseDownY + ( mouseY - mouseYOnMouseDown ) * 0.20;
	        };

	        function onDocumentMouseUp( event ) {

	        	document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
	        	document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
	        	document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
	        };

	        function onDocumentMouseOut( event ) {

	        	document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
	        	document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
	        	document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
	        };


            onWindowResize();
            document.addEventListener( 'mousedown', onDocumentMouseDown, false );
            window.addEventListener( 'resize', onWindowResize, false );
            render();
        </script>
        </div>
        <div id="hello">
            <h3> Say hi my friends, this should be the title! </h3>
        </div>
        <div id="bye">
            <h4> If i can get my css right, this will be at the bottom </h4>
            <p> this  p tag is just a bunch of jabrooni </p>
        </div>
    </body>
</html>

