<html>
    <head>
        <title> Threejs bs </title>
        <style> canvas { width: 100%; height: 100% } </style>
    </head>
    <body>
        <script src="js/three.min.js"></script>

        <script id="vertexShader" type="x-shader/x-vertex">
            varying vec2 vUv;

            void main() {
                vUv = uv;
                vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                gl_Position = projectionMatrix * mvPosition;
            }

        </script>
        <script id="fragmentShader" type="x-shader/x-fragment">
			uniform float time;
			uniform vec2 resolution;
			varying vec2 vUv;
            
            void main( void ) {

			vec2 position = vUv;
			float color = 0.0;
			color += sin( position.x * cos( time / 15.0 ) * 80.0 ) + cos( position.y * cos( time / 15.0 ) * 10.0 );
			color += sin( position.y * sin( time / 10.0 ) * 40.0 ) + cos( position.x * sin( time / 25.0 ) * 40.0 );
			color += sin( position.x * sin( time / 5.0 ) * 10.0 ) + sin( position.y * sin( time / 35.0 ) * 80.0 );
			color *= sin( time / 10.0 ) * 0.5;
			gl_FragColor = vec4( vec3( color, color * 0.5, sin( color + time / 3.0 ) * 0.75 ), 1.0 );

			}

		</script>
        <script>
            // our bs goes here
            var scene = new THREE.Scene();
            scene.fog = new THREE.Fog( 0xcce0ff, 500, 10000 );
            var clock = new THREE.Clock();

            // camera
            var camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 10000 );
            camera.position.y = 0;
            camera.position.z = 10;
            scene.add( camera );

            var light = new THREE.DirectionalLight( 0x404040 ); 
            light.position.set( 50, 200, 100 );
            light.position.multiplyScalar( 1.3 );
            light.castShadow = true;
            light.shadowMapWidth = 2048;
            light.shadowMapHeight = 2048;

            var d = 300;
            light.shadowCameraLeft = -d;
            light.shadowCameraRight = d;
            light.shadowCameraTop = d;
            light.shadowCameraBottom = -d;
            light.shadowCameraFar = 1000;
            light.shadowDarkness = 0.5;
            scene.add( light );

            light = new THREE.DirectionalLight( 0x3dff0c, 0.35 );
            light.position.set( 0, -1, 0 );
            scene.add( light );

            // ground
            var initColor = new THREE.Color( 0x497f13 );
            var initTexture = THREE.ImageUtils.generateDataTexture( 1, 1, initColor );
            var groundMaterial = new THREE.MeshPhongMaterial( 
                { color: 0xffffff, specular: 0x111111, map: initTexture } );

            var groundTexture = THREE.ImageUtils.loadTexture( "textures/grasslight-big.jpg", 
                undefined, function() { groundMaterial.map = groundTexture } );

            groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set( 25, 25 );
            groundTexture.anisotropy = 16;

            var mesh = new THREE.Mesh( new THREE.PlaneGeometry( 20000, 20000 ), groundMaterial );
            mesh.position.y = -250;
            mesh.rotation.x = - Math.PI / 2;
            mesh.receiveShadow = true;
            scene.add( mesh );

            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor( scene.fog.color );
            document.body.appendChild(renderer.domElement);

            var geometry = new THREE.CubeGeometry(1,1,1);
            //var material = new THREE.MeshBasicMaterial( {color: 0x0000ff} );

            // post proc
            var uniforms = {
                time: { type: "f", value: 1.0 },
                resolution: { type: "v2", value: new THREE.Vector2() }
            };

            var material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById( 'vertexShader' ).textContent,
                fragmentShader: document.getElementById( 'fragmentShader' ).textContent
            });

            var cube = new THREE.Mesh(geometry, material);
            scene.add(cube);

            function onWindowResize( event ) {
                uniforms.resolution.value.x = window.innerWidth;
                uniforms.resolution.value.y = window.innerHeight;
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }

            function render() {
                requestAnimationFrame(render);

                var delta = clock.getDelta();
                uniforms.time.value += delta * 5;     

                cube.rotation.x += 0.1;
                cube.rotation.y += 0.1;
              
                renderer.render(scene, camera);
            }

            render();



        </script>
    </body>
</html>
           
